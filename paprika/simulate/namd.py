import abc
import logging
import os
import subprocess as sp
from collections import OrderedDict
from enum import Enum

import numpy as np
import parmed as pmd

from paprika.utils import get_dict_without_keys

from .base_class import BaseSimulation

logger = logging.getLogger(__name__)


class NAMD(BaseSimulation, abc.ABC):
    """
    A wrapper that can be used to set NAMD simulation parameters.

    .. todo ::
        Add wrapper support for Drude polarizable FF, steered-MD and alchemical calculations

    Below is an example of the configuration file (``namd.in``) generated by the wrapper. The class property associated
    with defining the configuration variables is shown in brackets.

    .. code ::

        ## NPT MD Simulation [self.title]
        # AMBER files [self.topology, self.coordinates]
        amber                          yes
        parmfile                       cb6-but-dum-sol.prmtop
        ambercoor                      cb6-but-dum-sol.rst7
        readexclusions                 yes
        scnb                           2.0
        # Previous state [self.checkpoint]
        bincoordinates                 equilibration.restart.coor
        binvelocities                  equilibration.restart.vel
        extendedSystem                 equilibration.restart.xsc
        # Output control [self.control]
        outputname                     equilibration
        restartFreq                    5000
        dcdFreq                        500
        xstFreq                        500
        outputEnergies                 500
        outputPressure                 500
        timestep                       2.0
        # Nonbonded options [self.nb_method]
        exclude                        scaled1-4
        1-4scaling                     0.833333
        cutoff                         9.0
        LJCorrection                   yes
        nonbondedFreq                  1
        fullElectFrequency             2
        switching                      off
        wrapAll                        on
        margin                         10
        PME                            yes
        PMEGridSpacing                 1.0
        stepspercycle                  10
        # constraints [self.constraints]
        rigidBonds                     all
        rigidIterations                100
        rigidTolerance                 1.0e-8
        usesettle                      on
        # Temperature coupling [self.thermostat]
        langevin                       on
        langevinDamping                1.0
        langevinTemp                   298.15
        langevinHydrogen               off
        # Pressure coupling [self.barostat]
        useGroupPressure               yes
        useFlexibleCell                no
        useConstantArea                no
        langevinPiston                 on
        langevinPistonTarget           1.01325
        langevinPistonPeriod           200.0
        langevinPistonDecay            20.0
        langevinPistonTemp             298.15
        # Collective variables [self.colvars_file]
        colvars                        on
        colvarsConfig                  colvars.tcl
        # Molecular dynamics [self.control]
        run                            1500000
    """

    class Thermostat(Enum):
        """
        An enumeration of the different themostat implemented in NAMD.
        """

        Langevin = "Langevin dynamics"
        tCouple = "Temperature Coupling"
        tRescale = "Temperature Rescaling"
        vRescale = "Velocity Rescaling"
        tReassign = "Temperature Reassignment"
        LoweAnderson = "Lowe-Andersen dynamics"

    class Barostat(Enum):
        """
        An enumeration of the different barostat implemented in NAMD.
        """

        Berendsen = "Berendsen pressure bath"
        Langevin = "NosÃ©-Hoover Langevin piston"

    @property
    def colvars_file(self) -> os.PathLike:
        """os.PathLike: The name of the `Colvars` restraints file."""
        return self._colvars_file

    @colvars_file.setter
    def colvars_file(self, value: os.PathLike):
        self._colvars_file = value

    @property
    def tcl_forces(self) -> os.PathLike:
        """
        os.PathLike: The name of a `TclForces` scripts for applying a user defined force.
        https://www.ks.uiuc.edu/Research/namd/2.14/ug/node50.html

        .. note ::

            ``TclForces`` can by used to apply forces and/or on-the-fly analysis. An example use if this feature
            could be to generate a funnel potential. https://github.com/jeff231li/funnel_potential
        """
        return self._tcl_forces

    @tcl_forces.setter
    def tcl_forces(self, value: os.PathLike):
        self._tcl_forces = value

    @property
    def control(self) -> dict:
        """dict: Dictionary for the output control of the MD simulation (timestep, frequency of energy, trajectory
        etc)."""
        return self._control

    @control.setter
    def control(self, value: dict):
        self._control = value

    @property
    def nb_method(self) -> dict:
        """dict:Dictionary for the non-bonded method options (cutoffs and methods)."""
        return self._nb_method

    @nb_method.setter
    def nb_method(self, value: dict):
        self._nb_method = value

    @property
    def constraints(self) -> dict:
        """dict: Dictionary for the bond constraint options (rigid bonds and settle/shake)."""
        return self._constraints

    @constraints.setter
    def constraints(self, value):
        self._constraints = value

    @property
    def implicit(self) -> dict:
        """dict: Dictionary for implicit solvent options (Generalized Born Implicit Solvent model)."""
        return self._implicit

    @implicit.setter
    def implicit(self, value: dict):
        self._implicit = value

    @property
    def charmm_parameters(self) -> list:
        """list: A list CHARMM parameter file(s) if running simulations with the CHARMM force field."""
        return self._charmm_parameters

    @charmm_parameters.setter
    def charmm_parameters(self, value: list):
        self._charmm_parameters = value

    @property
    def prefix(self) -> str:
        """
        str: The prefix for file names generated from this simulation.
        """
        return self._prefix

    @prefix.setter
    def prefix(self, new_prefix: str):
        self._prefix = new_prefix
        self.input = new_prefix + ".in"
        self.logfile = new_prefix + ".log"

    @property
    def checkpoint(self) -> str:
        """
        str: Specify the prefix file name for the previous simulation (as checkpoint for continuing a simulation).
        This is needed to get the coordinates ``*.coor``, velocities ``*.vel`` and box information ``*.xsc``.
        Unlike AMBER and GROMACS, NAMD requires the restart files specified inside the configuration file instead of
        the command-line argument and the information is stored in different files.
        """
        return self._checkpoint

    @checkpoint.setter
    def checkpoint(self, value: str):
        self._checkpoint = value

    @property
    def cell_basis_vectors(self):
        """
        dict: Dictionary for the cell basis vectors (``cellBasisVector1``, ``cellBasisVector2``, ``cellBasisVector3``
        and ``cellOrigin``). If not defined, the basis vectors and the origin can be calculated from the positions
        of the system from the coordinates files.
        """
        return self._cell_basis_vectors

    @cell_basis_vectors.setter
    def cell_basis_vectors(self, value):
        self._cell_basis_vectors = value

    @property
    def custom_run_commands(self) -> list:
        """
        list: A list of NAMD-supported Tcl commands if a custom run is preferred. The code-snippet below shows an
        example use of this command for a simulation with a `slow-heating` protocol.

        .. code-block :: python

            >>> simulation.custom_run_commands = [
            >>>     "for {set temp 0} {$temp <= 300} {incr temp 50} {",
            >>>     "langevinTemp $temp",
            >>>     "reinitvels $temp",
            >>>     "run 50000",
            >>>     "}",
            >>> ]
        """
        return self._custom_run_commands

    @custom_run_commands.setter
    def custom_run_commands(self, value: list):
        self._custom_run_commands = value

    @property
    def qmForces(self) -> dict:
        """dict: Dictionary for setting QM/MM simulation parameters in NAMD
        https://www.ks.uiuc.edu/Research/namd/2.14/ug/node84.html.

        .. note ::

            ``qmForces`` in NAMD can also be used to run simulations with Neural Network Potentials (NNP)
            https://github.com/RowleyGroup/NNP-MM.

        """
        return self._qmForces

    @qmForces.setter
    def qmForces(self, value: dict):
        self._qmForces = value

    def __init__(self):

        super().__init__()

        # I/O
        self._colvars_file = None

        # File names
        self.input = self._prefix + ".in"
        self.logfile = self._prefix + ".log"
        self._checkpoint = None
        self._custom_run_commands = None
        self._tcl_forces = None
        self._charmm_parameters = []

        self._qmForces = {}

        self._constraints = OrderedDict()
        self._constraints["rigidBonds"] = "all"
        self._constraints["rigidTolerance"] = 1.0e-8
        self._constraints["rigidIterations"] = 100
        self._constraints["usesettle"] = "on"

        self._nb_method = OrderedDict()
        self._nb_method["exclude"] = "scaled1-4"
        self._nb_method["1-4scaling"] = 0.833333
        self._nb_method["cutoff"] = 9.0
        self._nb_method["LJCorrection"] = "yes"
        self._nb_method["nonbondedFreq"] = 1
        self._nb_method["fullElectFrequency"] = 2
        self._nb_method["switching"] = "off"
        self._nb_method["wrapAll"] = "on"
        self._nb_method["margin"] = 5.0

        # Placeholder dict
        self._control = {}
        self._implicit = OrderedDict()
        self._cell_basis_vectors = OrderedDict()

    def _config_min(self):
        """
        Configure input settings for minimization.
        """
        self.control["outputname"] = self.prefix
        self.control["minimize"] = 5000

        if ".prmtop" in self.topology:
            self.control["readexclusions"] = "yes"
            self.control["scnb"] = 2.0

        elif ".psf" in self.topology:
            self.nb_method["1-4scaling"] = 1.0
            self.nb_method["cutoff"] = 12.0
            self.nb_method["switching"] = "on"
            self.nb_method["switchdist"] = 10.0
            self.nb_method["exclude"] = "scaled1-4"
            self.nb_method["LJCorrection"] = "off"

        self.control["restartFreq"] = 5000
        self.control["dcdFreq"] = 500
        self.control["xstFreq"] = 500
        self.control["outputEnergies"] = 500
        self.control["outputPressure"] = 500

        if "namd3" in self.executable:
            self.nb_method["CUDASOAintegrate"] = "off"

    def _config_md(self, thermostat):
        """
        Configure input settings for MD.

        Parameters
        ----------
        thermostat: :class:`NAMD.Thermostat`, optional, default=Langevin
            Option to choose one of five thermostat implemented in NAMD: (1) `Langevin`, (2) `tCouple`, (3) `tRescale`,
            (4) `tReassign`, (5) `Lowe-Anderson`.

        """
        self.control["outputname"] = self.prefix
        self.control["restartFreq"] = 5000
        self.control["dcdFreq"] = 500
        self.control["xstFreq"] = 500
        self.control["outputEnergies"] = 500
        self.control["outputPressure"] = 500
        self.control["run"] = 5000
        self.control["timestep"] = 2.0

        if ".prmtop" in self.topology:
            self.control["readexclusions"] = "yes"
            self.control["scnb"] = 2.0

        elif ".psf" in self.topology:
            self.nb_method["1-4scaling"] = 1.0
            self.nb_method["cutoff"] = 12.0
            self.nb_method["switching"] = "on"
            self.nb_method["switchdist"] = 10.0
            self.nb_method["exclude"] = "scaled1-4"
            self.nb_method["LJCorrection"] = "no"

        if "namd3" in self.executable:
            self.nb_method["CUDASOAintegrate"] = "on"
        else:
            self.nb_method["margin"] = 1.0
            self.nb_method["stepspercycle"] = 10

        # Select Thermotat for the simulation
        if thermostat == self.Thermostat.Langevin:
            self.thermostat["langevin"] = "on"
            self.thermostat["langevinDamping"] = 1.0
            self.thermostat["langevinTemp"] = self.temperature
            self.thermostat["langevinHydrogen"] = "off"

        elif thermostat == self.Thermostat.tCouple:
            self.thermostat["tCouple"] = "on"
            self.thermostat["tCoupleTemp"] = self.temperature

        elif thermostat == self.Thermostat.tRescale:
            self.thermostat["rescaleFreq"] = 50
            self.thermostat["rescaleTemp"] = self.temperature

        elif thermostat == self.Thermostat.vRescale:
            self.thermostat["stochRescale"] = "on"
            self.thermostat["stochRescaleTemp"] = self.temperature
            self.thermostat["stochRescalePeriod"] = 1.0

        elif thermostat == self.Thermostat.tReassign:
            self.thermostat["reassignFreq"] = 50
            self.thermostat["reassignTemp"] = self.temperature

        elif thermostat == self.Thermostat.LoweAnderson:
            self.thermostat["loweAndersen"] = "on"
            self.thermostat["loweAndersenCutoff"] = 2.7
            self.thermostat["loweAndersenTemp"] = self.temperature
            self.thermostat["loweAndersenRate"] = 50

    def config_gb_min(self):
        """
        Configure a reasonable input settings for minimization with implicit solvent. `Users can override the parameters
        set by this method.`
        """
        self.title = "Implicit solvent Minimization"

        self._config_min()

        self.implicit["GBIS"] = "on"
        self.implicit["solventDielectric"] = 78.5
        self.implicit["ionConcentration"] = 0.0

        self.nb_method["cutoff"] = 999.0
        self.nb_method["LJCorrection"] = "no"
        self.nb_method["nonbondedFreq"] = 2
        self.nb_method["fullElectFrequency"] = 4
        self.nb_method["wrapAll"] = "off"

        if ".psf" in self.topology:
            self.nb_method["switching"] = "off"
            del self.nb_method["switchdist"]

    def config_gb_md(self, thermostat=Thermostat.Langevin):
        """
        Configure a reasonable input settings for MD with implicit solvent. `Users can override the parameters
        set by this method.`

        Parameters
        ----------
        thermostat: :class:`NAMD.Thermostat`, optional, default=Langevin
            Option to choose one of six thermostat implemented in NAMD: (1) `Langevin`, (2) `tCouple`,
            (3) `tRescale`, (4) `vRescale`, (5) `tReassign`, (6) `Lowe-Anderson`.
        """
        self.title = "Implicit solvent MD Simulation"

        self._config_md(thermostat)

        self.implicit["GBIS"] = "on"
        self.implicit["solventDielectric"] = 78.5
        self.implicit["ionConcentration"] = 0.0

        self.control["timestep"] = 1.0

        self.nb_method["cutoff"] = 999.0
        self.nb_method["LJCorrection"] = "no"
        self.nb_method["nonbondedFreq"] = 2
        self.nb_method["fullElectFrequency"] = 4
        self.nb_method["wrapAll"] = "off"
        self.nb_method["stepspercycle"] = 20

        if ".psf" in self.topology:
            self.nb_method["switching"] = "off"
            del self.nb_method["switchdist"]

    def config_pbc_min(self, calculate_cell_vectors=True):
        """
        Configure a reasonable input setting for an energy minimization run with periodic boundary conditions. `Users
        can override the parameters set by this method.`

        Parameters
        ----------
        calculate_cell_vectors: bool, optional, default=True
            Calculate cell basis vectors based on ``self.coordinates``. This is usually needed at the start of a
            simulation. When continuing from a previous a simulation NAMD reads in the ``*.xsc`` file to get the basis
            vectors.

        """
        self.title = "PBC Minimization"

        self._config_min()

        self.nb_method["PME"] = "yes"
        self.nb_method["PMEGridSpacing"] = 1.0

        if calculate_cell_vectors:
            self._get_cell_basis_vectors()

    def config_pbc_md(
        self,
        ensemble="npt",
        thermostat=Thermostat.Langevin,
        barostat=Barostat.Langevin,
        calculate_cell_vectors=False,
    ):
        """
        Configure a reasonable input setting for a MD run with periodic boundary conditions. `Users can override the
        parameters set by this method.`

        Parameters
        ----------
        ensemble: str, optional, default="npt"
            Configure MD setting to use ``nvt`` or ``npt``.
        thermostat: :class:`NAMD.Thermostat`, optional, default='Langevin'
            Option to choose one of six thermostat implemented in NAMD: (1) `Langevin`, (2) `tCouple`,
            (3) `tRescale`, (4) `vRescale`, (5) `tReassign`, (6) `Lowe-Anderson`.
        barostat: :class:`NAMD.Barostat`, optional, default='Langevin'
            Option to choose one of two barostat implemented in NAMD: (1) `Langevin` piston or (2) `Berendsen`.
        calculate_cell_vectors: bool, optional, default=False
            Calculate cell basis vectors based on ``self.coordinates``. This is usually needed at the start of a
            simulation. When continuing from a previous a simulation NAMD reads in the ``*.xsc`` file to get the cell
            basis vectors.

        """
        if ensemble.lower() not in ["nve", "nvt", "npt"]:
            raise Exception(f"Thermodynamic ensemble {ensemble} is not supported.")

        self.title = f"{ensemble.upper()} MD Simulation"

        if ensemble.lower() == "nve":
            self._config_md(thermostat=None)
            self.control["timestep"] = 1.0
        else:
            self._config_md(thermostat)

        self.nb_method["PME"] = "yes"
        self.nb_method["PMEGridSpacing"] = 1.0

        # Select Barostat for the simulation
        if ensemble.lower() == "npt":
            self.barostat["useGroupPressure"] = "yes"
            self.barostat["useFlexibleCell"] = "no"
            self.barostat["useConstantArea"] = "no"

            if barostat == self.Barostat.Langevin:
                self.barostat["langevinPiston"] = "on"
                self.barostat["langevinPistonTarget"] = self.pressure
                self.barostat["langevinPistonPeriod"] = 200.0
                self.barostat["langevinPistonDecay"] = 100.0
                self.barostat["langevinPistonTemp"] = self.temperature

            elif barostat == self.Barostat.Berendsen:
                self.barostat["BerendsenPressure"] = "on"
                self.barostat["BerendsenPressureTarget"] = self.pressure
                self.barostat["BerendsenPressureCompressibility"] = 4.57e-5
                self.barostat["BerendsenPressureRelaxationTime"] = 100
                self.barostat["BerendsenPressureFreq"] = 10

        if calculate_cell_vectors:
            self._get_cell_basis_vectors()

    def _get_cell_basis_vectors(self):
        """
        Function to calculate the PBC cell basis vectors (needed when running a simulation for the first time).
        """
        structure = pmd.load_file(
            os.path.join(self.path, self.topology),
            os.path.join(self.path, self.coordinates),
            structure=True,
        )
        coordinates = structure.coordinates
        masses = np.ones(len(coordinates))
        center = pmd.geometry.center_of_mass(coordinates, masses)

        self.cell_basis_vectors["cellOrigin"] = list(center)

        # Check if box info exists
        if structure.box_vectors:
            import simtk.unit as unit

            self.cell_basis_vectors["cellBasisVector1"] = structure.box_vectors[
                0
            ].value_in_unit(unit.angstroms)
            self.cell_basis_vectors["cellBasisVector2"] = structure.box_vectors[
                1
            ].value_in_unit(unit.angstroms)
            self.cell_basis_vectors["cellBasisVector3"] = structure.box_vectors[
                2
            ].value_in_unit(unit.angstroms)

        else:
            self.cell_basis_vectors["cellBasisVector1"] = [
                structure.coordinates[:, 0].max() - structure.coordinates[:, 0].min(),
                0.0,
                0.0,
            ]
            self.cell_basis_vectors["cellBasisVector2"] = [
                0.0,
                structure.coordinates[:, 1].max() - structure.coordinates[:, 1].min(),
                0.0,
            ]
            self.cell_basis_vectors["cellBasisVector3"] = [
                0.0,
                0.0,
                structure.coordinates[:, 2].max() - structure.coordinates[:, 2].min(),
            ]

    @staticmethod
    def _write_dict_to_conf(f, dictionary):
        """
        Write dictionary to file, following NAMD format.

        Parameters
        ----------
        f : TextIO
            File where the dictionary should be written.
        dictionary : dict
            Dictionary of values.

        """
        for key, val in dictionary.items():
            if val is not None and not isinstance(val, list):
                f.write("{:30s} {:s}\n".format(key, str(val)))
            elif isinstance(val, list):
                f.write("{:30s} ".format(key))
                for i in val:
                    f.write("{:s} ".format(str(i)))
                f.write("\n")

    def _write_input_file(self):
        """
        Write the MD configuration to file.
        """

        logger.debug("Writing input file: {}".format(self.input))

        with open(os.path.join(self.path, self.input), "w") as conf:
            conf.write("## {:s}\n".format(self.title))

            # Topology and Coordinates files
            # AMBER PRMTOP/RST7
            if ".prmtop" in self.topology:
                conf.write("# AMBER files\n")
                conf.write("{:30s} {:s}\n".format("amber", "yes"))
                conf.write("{:30s} {:s}\n".format("parmfile", self.topology))

                if any([ext in self.coordinates for ext in [".rst7", ".inpcrd"]]):
                    conf.write("{:30s} {:s}\n".format("ambercoor", self.coordinates))
                elif ".pdb" in self.coordinates:
                    conf.write("{:30s} {:s}\n".format("coordinates", self.coordinates))
                else:
                    raise FileExistsError(
                        f"Coordinates file {self.coordinates} not does not exist."
                    )

                conf.write(
                    "{:30s} {:s}\n".format(
                        "readexclusions", self.control["readexclusions"]
                    )
                )
                conf.write("{:30s} {:s}\n".format("scnb", str(self.control["scnb"])))

            # GROMACS TOP/GRO
            elif ".top" in self.topology:
                conf.write("# GROMACS files\n")
                conf.write("{:30s} {:s}\n".format("gromacs", "on"))
                conf.write("{:30s} {:s}\n".format("grotopfile", self.topology))

                if ".gro" in self.coordinates:
                    conf.write("{:30s} {:s}\n".format("grocoorfile", self.coordinates))
                elif ".pdb" in self.coordinates:
                    conf.write("{:30s} {:s}\n".format("coordinates", self.coordinates))
                else:
                    raise FileExistsError(
                        f"Coordinates file {self.coordinates} not does not exist."
                    )

            # CHARMM PSF/PDB
            elif ".psf" in self.topology:
                conf.write("# CHARMM files\n")
                conf.write("{:30s} {:s}\n".format("paraTypeXplor", "on"))
                conf.write("{:30s} {:s}\n".format("structure", self.topology))

                if ".pdb" in self.coordinates:
                    conf.write("{:30s} {:s}\n".format("coordinates", self.coordinates))
                else:
                    raise FileExistsError(
                        f"Coordinates file {self.coordinates} not does not exist."
                    )

                if not self.charmm_parameters:
                    raise FileExistsError(
                        "CHARMM parameter file(s) not specified, please specify the parameters "
                        "with the variable 'namd.charmm_parameters'."
                    )

                conf.write("{:30s} {:s}\n".format("paraTypeCharmm ", "on"))
                for parameter in self.charmm_parameters:
                    conf.write("{:30s} {:s}\n".format("parameters", parameter))

            # Load in previous files (.coor, .vel and/or .xsc)
            if self.checkpoint is not None:
                conf.write("# Previous state\n")

                # Coordinates
                bincoordinates = self.checkpoint + ".restart.coor"
                if not os.path.isfile(os.path.join(self.path, bincoordinates)):
                    bincoordinates = self.checkpoint + ".coor"

                conf.write("{:30s} {:s}\n".format("bincoordinates", bincoordinates))

                # Velocities
                binvelocities = self.checkpoint + ".restart.vel"
                if not os.path.isfile(os.path.join(self.path, binvelocities)):
                    binvelocities = self.checkpoint + ".vel"

                conf.write("{:30s} {:s}\n".format("binvelocities", binvelocities))

                # PBC box information
                if not self.implicit:
                    extendedsystem = self.checkpoint + ".restart.xsc"
                    if not os.path.isfile(os.path.join(self.path, extendedsystem)):
                        extendedsystem = self.checkpoint + ".xsc"

                    conf.write("{:30s} {:s}\n".format("extendedSystem", extendedsystem))

            else:
                conf.write("{:30s} {:s}\n".format("temperature", str(self.temperature)))

            conf.write("# Output control\n")
            self._write_dict_to_conf(
                conf,
                get_dict_without_keys(
                    self.control,
                    "minimize",
                    "run",
                    "readexclusions",
                    "scnb",
                ),
            )

            if self.implicit:
                conf.write("# Generalized Born Implicit Solvent\n")
                self._write_dict_to_conf(conf, self.implicit)

            if self.cell_basis_vectors:
                conf.write("# Cell basis vectors\n")
                self._write_dict_to_conf(conf, self.cell_basis_vectors)

            conf.write("# Nonbonded options\n")
            self._write_dict_to_conf(conf, self.nb_method)

            conf.write("# constraints\n")
            self._write_dict_to_conf(conf, self.constraints)

            conf.write("# Temperature coupling\n")
            if self.custom_run_commands:
                if any(["langevinTemp" in line for line in self.custom_run_commands]):
                    self._write_dict_to_conf(
                        conf, get_dict_without_keys(self.thermostat, "langevinTemp")
                    )
                else:
                    self._write_dict_to_conf(conf, self.thermostat)
            else:
                self._write_dict_to_conf(conf, self.thermostat)

            if self.barostat:
                conf.write("# Pressure coupling\n")
                self._write_dict_to_conf(conf, self.barostat)

            if self.colvars_file:
                conf.write("# Collective variables\n")
                conf.write("{:30s} {:s}\n".format("colvars", "on"))
                conf.write("{:30s} {:s}\n".format("colvarsConfig", self.colvars_file))

            if self.plumed_file:
                conf.write("# Plumed Restraints\n")
                conf.write("{:30s} {:s}\n".format("plumed", "on"))
                conf.write("{:30s} {:s}\n".format("plumedfile", self.plumed_file))

            if self.tcl_forces:
                conf.write("# TclForces\n")
                conf.write("{:30s} {:s}\n".format("tclForces", "on"))
                conf.write("{:30s} {:s}\n".format("tclForcesScript", self.tcl_forces))

            if self.qmForces:
                conf.write("# QM Forces\n")
                self._write_dict_to_conf(conf, self.qmForces)

            if not self.custom_run_commands:
                if "minimize" in self.control:
                    conf.write("# Minimization\n")
                    conf.write(
                        "{:30s} {:s}\n".format(
                            "minimize", str(self.control["minimize"])
                        )
                    )
                elif "run" in self.control:
                    conf.write("# Molecular dynamics\n")
                    conf.write("{:30s} {:s}\n".format("run", str(self.control["run"])))
            else:
                conf.write("# Custom Run\n")
                for line in self.custom_run_commands:
                    conf.write(line + "\n")

    def run(self, overwrite=True, fail_ok=False):
        """
        Method to run Molecular Dynamics simulation with NAMD.

        Parameters
        ----------
        overwrite: bool, optional, default=False
            Whether to overwrite simulation files.
        fail_ok: bool, optional, default=False
            Whether a failing simulation should stop execution of ``pAPRika``.

        """

        if overwrite or not self.check_complete():
            if "Minimization" in self.title:
                logger.info("Running Minimization at {}".format(self.path))
            elif "MD Simulation" in self.title:
                if self.thermostat and self.barostat:
                    logger.info("Running NPT MD at {}".format(self.path))
                elif not self.barostat:
                    logger.info("Running NVT MD at {}".format(self.path))
                else:
                    logger.info("Running NVE MD at {}".format(self.path))

            # Check restraints file
            if self.colvars_file and self.plumed_file:
                raise Exception(
                    "Cannot use both Colvars-style and Plumed-style restraints at the same time."
                )

            # Set Plumed kernel library to path
            if self.plumed_file:
                self._set_plumed_kernel()

            # Write input file
            self._write_input_file()

            # Create executable list
            exec_list = self.executable.split()

            if "+p" not in self.executable:
                exec_list += ["+p", str(self.n_threads)]

            if "+devices" not in self.executable and self.gpu_devices is not None:
                exec_list += ["+devices", str(self.gpu_devices)]

            exec_list += [self.input]

            logger.debug("Exec line: " + " ".join(exec_list))

            # Execute
            namd_output = sp.Popen(
                exec_list,
                cwd=self.path,
                stdout=open(os.path.join(self.path, self.logfile), "w"),
                stderr=sp.PIPE,
                env=os.environ,
            )
            namd_stderr = namd_output.stderr.read().splitlines()

            if namd_stderr and any(
                ["ERROR:" in line.decode("utf-8").strip() for line in namd_stderr]
            ):
                logger.info("STDERR received from NAMD execution")
                for line in namd_stderr:
                    logger.error(line)

            # Check completion status
            if "minimize" in self.control and self.check_complete():
                logger.info("Minimization completed...")
            elif self.check_complete():
                logger.info("MD completed ...")
            else:
                logger.info(
                    "Simulation did not complete when executing the following ...."
                )
                logger.info(" ".join(exec_list))
                if not fail_ok:
                    raise Exception(
                        "Exiting due to failed simulation! Check logging info."
                    )
        else:
            logger.info(
                "Completed output detected ... Skipping. Use: run(overwrite=True) to overwrite"
            )

    def check_complete(self, alternate_file=None):
        """
        Check for the string "WallClock" in ``self.logfile`` file. If "WallClock" is found, then
        the simulation completed.

        Parameters
        ----------
        alternate_file : os.PathLike, optional, default=None
            If present, check for "WallClock" in this file rather than ``self.logfile``.
            Default: None

        Returns
        -------
        complete : bool
            True if "WallClock" is found in file. False, otherwise.
        """
        # Assume not completed
        complete = False

        if alternate_file:
            output_file = alternate_file
        else:
            output_file = os.path.join(self.path, self.logfile)

        if os.path.isfile(output_file):
            with open(output_file, "r") as f:
                strings = f.read()
                if "WallClock:" in strings:
                    complete = True

        if complete:
            logger.debug("{} has TIMINGS".format(output_file))
        else:
            logger.debug("{} does not have TIMINGS".format(output_file))

        return complete
