import abc
import glob
import logging
import os
import subprocess
from collections import OrderedDict
from enum import Enum

from paprika.utils import get_dict_without_keys

from .simulation import Simulation

logger = logging.getLogger(__name__)


class GROMACS(Simulation, abc.ABC):
    """
    A wrapper that can be used to set GROMACS simulation parameters.

    .. todo ::
        possibly modify this module to use the official python wrapper of GROMACS.

    Below is an example of the configuration file (``gromacs.mdp``) generated by the wrapper. The class property
    associated with defining the configuration variables is shown in brackets.

    .. code ::

        title                     = NPT MD Simulation ; [self.title]
        ; Run control [self.control]
        nsteps                    = 1500000
        nstxout                   = 500
        nstlog                    = 500
        nstenergy                 = 500
        nstcalcenergy             = 500
        dt                        = 0.002
        integrator                = md
        ; Nonbonded options [self.nb_method]
        cutoff-scheme             = Verlet
        ns_type                   = grid
        nstlist                   = 10
        rlist                     = 0.9
        rcoulomb                  = 0.9
        rvdw                      = 0.9
        coulombtype               = PME
        pme_order                 = 4
        fourierspacing            = 0.16
        vdwtype                   = Cut-off
        DispCorr                  = EnerPres
        pbc                       = xyz
        ; Bond constraints [self.constraints]
        constraint-algorithm      = lincs
        constraints               = h-bonds
        lincs_iter                = 1
        lincs_order               = 4
        ; Temperature coupling [self.thermostat]
        tcoupl                    = v-rescale
        tc-grps                   = System
        ref_t                     = 298.15
        tau_t                     = 0.1
        gen_vel                   = no
        ; Pressure coupling [self.barostat]
        pcoupl                    = Berendsen
        pcoupltype                = isotropic
        tau_p                     = 2.0
        ref_p                     = 1.01325
        compressibility           = 4.5e-05
    """

    class Thermostat(Enum):
        """
        An enumeration of the different themostat implemented in GROMACS.
        """

        Off = "no"
        Berendsen = "berendsen"
        NoseHoover = "nose-hoover"
        Andersen1 = "andersen"
        Andersen2 = "andersen-massive"
        VelocityRescaling = "v-rescale"

    class Barostat(Enum):
        """
        An enumeration of the different barostat implemented in GROMACS.
        """

        Off = "no"
        Berendsen = "Berendsen"
        ParrinelloRahman = "Parrinello-Rahman"
        MMTK = "MTTK"

    class Integrator(Enum):
        """
        An enumeration of the different integrators implemented in GROMACS.
        """

        LeapFrog = "md"
        VelocityVerlet = "md-vv"
        VelocityVerletAveK = "md-vv-avek"
        LangevinDynamics = "sd"
        BrownianDynamics = "bd"

    class Optimizer(Enum):
        """
        An enumeration of the different minimization algorithm implemented in GROMACS.
        """

        SteepestDescent = "steep"
        ConjugateGradient = "cg"
        Broyden = "l-bfgs"

    class BoxScaling(Enum):
        """
        An enumeration of the different PBC scaling options when running constant pressure simulations in GROMACS.
        """

        Isotropic = "isotropic"
        Semiisotropic = "semiisotropic"
        Anisotropic = "anisotropic"
        SurfaceTension = "surface-tension"

    class Constraints(Enum):
        """
        An enumeration of the different bond constraint options in GROMACS.
        """

        Off = "none"
        HBonds = "h-bonds"
        AllBonds = "all-bonds"
        HAngles = "h-angles"
        AllAngles = "all-angles"

    @property
    def index_file(self) -> str:
        """os.PathLike: GROMACS index file that specifies ``groups`` in the system. This is optional in a GROMACS
        simulation."""
        return self._index_file

    @index_file.setter
    def index_file(self, value: str):
        self._index_file = value

    @property
    def checkpoint(self) -> str:
        """os.PathLike: Checkpoint file (extension is ``.cpt``) for starting a simulation from a previous state."""
        return self._checkpoint

    @checkpoint.setter
    def checkpoint(self, value: str):
        self._checkpoint = value

    @property
    def control(self):
        """dict: Dictionary for the output control of the MD simulation (frequency of energy, trajectory etc)."""
        return self._control

    @control.setter
    def control(self, value):
        self._control = value

    @property
    def nb_method(self):
        """dict: Dictionary for the non-bonded method options (cutoffs and methods)."""
        return self._nb_method

    @nb_method.setter
    def nb_method(self, value):
        self._nb_method = value

    @property
    def constraints(self):
        """dict: Dictionary for the bond constraint options (LINCS or SHAKE)."""
        return self._constraints

    @constraints.setter
    def constraints(self, value):
        self._constraints = value

    @property
    def tc_groups(self) -> list:
        """
        list: List of groups to apply thermostat "separately" based on the groups defined in the ``index_file``.
        Below is an example of applying the thermostat for different groups separately in a GROMACS input file

        .. code ::

            tcoupl  = v-rescale
            tc-grps = HOST GUEST HOH
            tau-t   = 0.1 0.1 0.1
            ref-t   = 300 300 300
        """
        return self._tc_groups

    @tc_groups.setter
    def tc_groups(self, value: list):
        self._tc_groups = value

    @property
    def prefix(self):
        """str: The prefix for file names generated from this simulation."""
        return self._prefix

    @prefix.setter
    def prefix(self, new_prefix):
        self._prefix = new_prefix
        self.input = new_prefix + ".mdp"
        self.output = new_prefix + ".mdout"
        self.logfile = new_prefix + ".log"
        self.tpr = new_prefix + ".tpr"

    @property
    def custom_mdrun_command(self) -> str:
        """Custom commands for ``mdrun``. The default commands parsed to ``mdrun`` if all the variables are defined is

        .. code::

            gmx mdrun -deffnm ``prefix`` -nt ``n_threads`` -gpu_id ``gpu_devices`` -plumed ``plumed.dat``

        This is useful depending on how GROMACS was compiled, e.g. if GROMACS is compiled with the MPI library the
        you will need to use the command below:

        .. code::

            mpirun -np 6 gmx_mpi mdrun -deffnm ``prefix`` -ntomp 1 -gpu_id 0 -plumed ``plumed.dat``
        """
        return self._custom_mdrun_command

    @custom_mdrun_command.setter
    def custom_mdrun_command(self, value: str):
        self._custom_mdrun_command = value

    @property
    def grompp_maxwarn(self) -> int:
        """int: Maximum number of warnings for GROMPP to ignore. default=1."""
        return self._grompp_maxwarn

    @grompp_maxwarn.setter
    def grompp_maxwarn(self, value: int):
        self._grompp_maxwarn = value

    def __init__(self):
        super().__init__()

        # I/O
        self._index_file = None
        self._custom_mdrun_command = None
        self._tc_groups = None
        self._grompp_maxwarn = 1

        # File names
        self.input = self._prefix + ".mdp"
        self.output = self._prefix + ".mdout"
        self._checkpoint = None
        self.logfile = self._prefix + ".log"
        self.tpr = self._prefix + ".tpr"

        # Input file
        self._control = OrderedDict()
        self._control["nsteps"] = 5000
        self._control["nstxout"] = 500
        self._control["nstlog"] = 500
        self._control["nstenergy"] = 500
        self._control["nstcalcenergy"] = 500

        self._constraints = OrderedDict()
        self._constraints["constraint-algorithm"] = "lincs"
        self._constraints["constraints"] = self.Constraints.HBonds.value
        self._constraints["lincs_iter"] = 1
        self._constraints["lincs_order"] = 4

        self._nb_method = OrderedDict()
        self._nb_method["cutoff-scheme"] = "Verlet"
        self._nb_method["ns-type"] = "grid"
        self._nb_method["nstlist"] = 10
        self._nb_method["rlist"] = 0.9
        self._nb_method["rcoulomb"] = 0.9
        self._nb_method["rvdw"] = 0.9
        self._nb_method["coulombtype"] = "PME"
        self._nb_method["pme_order"] = 4
        self._nb_method["fourierspacing"] = 0.16
        self._nb_method["vdwtype"] = "Cut-off"
        self._nb_method["DispCorr"] = "EnerPres"
        self._nb_method["pbc"] = "xyz"

    def _config_min(self, optimizer):
        """
        Configure input settings for a minimization run.

        Parameters
        ----------
        optimizer: :class:`GROMACS.Optimizer`, default=Optimizer.SteepestDescent
            Algorithm for energy minimization, keyword in the parenthesis are the options for the input file.
            **(1)** `SteepestDescent` (``steep``), **(2)** `ConjugateGradient` (``cg``), and **(3)** `Broyden`
            (``l-bfgs``).
        """
        self.constraints["continuation"] = "no"
        self.control["integrator"] = optimizer.value
        self.control["emtol"] = 10.0
        self.control["emstep"] = 0.01
        self.control["nsteps"] = 5000

    def _config_md(self, integrator, thermostat):
        """
        Configure input setting for a MD.

        Parameters
        ----------
        integrator: :class:`GROMACS.Integrator`, default=Integrator.LeapFrog
            Option to choose the integrator for the MD simulations, keywords in the parenthesis are the options for the
            input file. **(1)** `LeapFrog` (``md``), **(2)** `VelocityVerlet` (``md-vv``),
            **(3)** `VelocityVerletAveK` (``md-vv-avek``), **(4)** `LangevinDynamics` (``sd``), and **(5)**
            `Brownian Dynamics` (``bd``).
        integrator: :class:`GROMACS.Integrator`, default=Integrator.LeapFrog
            Option to choose the integrator for the MD simulations, keywords in the parenthesis are the options for the
            input file. **(1)** `LeapFrog` (``md``), **(2)** `VelocityVerlet` (``md-vv``),
            **(3)** `VelocityVerletAveK` (``md-vv-avek``), **(4)** `LangevinDynamics` (``sd``), and **(5)**
            `Brownian Dynamics` (``bd``).
        """
        self.control["dt"] = 0.002
        self.control["integrator"] = integrator.value
        self.constraints["continuation"] = "yes"
        self.thermostat["tc-grps"] = "System"
        self.thermostat["ref_t"] = self.temperature

        if (
            integrator != self.Integrator.LangevinDynamics
            and integrator != self.Integrator.BrownianDynamics
        ):
            self.thermostat["tcoupl"] = thermostat.value
            self.thermostat["tau_t"] = 1.0
        else:
            self.thermostat["tau_t"] = 0.1

    def config_vac_min(self, optimizer=Optimizer.SteepestDescent):
        """
        Configure a reasonable input setting for a MD run in vacuum. `Users can override the parameters set by this
        method.`

        .. note ::
            Newer versions of GMX no longer support a "True" vacuum simulation so we have to do this by creating a
            "pseudo-PBC" environment. Make sure the coordinates ``.gro`` file has an expanded box, which you can do
            using ``gmx editconf``. See the discussion on
            https://gromacs.bioexcel.eu/t/minimization-in-vacuum-without-pbc/110/2.

        Parameters
        ----------
        optimizer: :class:`GROMACS.Optimizer`, default=Optimizer.SteepestDescent
            Algorithm for energy minimization, keyword in the parenthesis are the options for the input file.
            **(1)** `SteepestDescent` (``steep``), **(2)** `ConjugateGradient` (``cg``), and **(3)** `Broyden`
            (``l-bfgs``).
        """

        self.title = "Vacuum Minimization"

        self._config_min(optimizer)

        self.nb_method["pbc"] = "xyz"
        self.nb_method["ns_type"] = "grid"
        self.nb_method["nstlist"] = 10
        self.nb_method["rlist"] = 333.3
        self.nb_method["coulombtype"] = "Cut-off"
        self.nb_method["rcoulomb"] = 333.3
        self.nb_method["vdwtype"] = "Cut-off"
        self.nb_method["rvdw"] = 333.3
        self.nb_method["DispCorr"] = "no"

    def config_vac_md(
        self, integrator=Integrator.LeapFrog, thermostat=Thermostat.VelocityRescaling
    ):
        """
        Configure a reasonable input setting for a MD run in vacuum. `Users can override the parameters set by this
        method.`

        .. note ::
            Newer versions of GMX no longer support a "True" vacuum simulation so we have to do this by creating a
            "pseudo-PBC" environment. Make sure the coordinates ``.gro`` file has an expanded box, which you set
            using ``gmx editconf``. See the discussion on
            https://gromacs.bioexcel.eu/t/minimization-in-vacuum-without-pbc/110/2.

        Parameters
        ----------
        integrator: :class:`GROMACS.Integrator`, default=Integrator.LeapFrog
            Option to choose the integrator for the MD simulations, keywords in the parenthesis are the options for the
            input file. **(1)** `LeapFrog` (``md``), **(2)** `VelocityVerlet` (``md-vv``),
            **(3)** `VelocityVerletAveK` (``md-vv-avek``), **(4)** `LangevinDynamics` (``sd``), and **(5)**
            `Brownian Dynamics` (``bd``).
        thermostat: :class:`GROMACS.Thermostat`, default=Thermostat.VelocityRescaling
            Option to choose one of five thermostat implemented in GROMACS, keywords in the parenthesis are the options
            for the input file. **(1)** `Off` (``no``), **(2)** `Berendsen` (``berendsen``), **(3)** `NoseHoover`
            (``nose-hoover``), **(4)** `Andersen1` (``andersen``), **(5)** `Andersen2` (``andersen-massive``),
            and **(6)** `VelocityRescaling` (``v-rescale``).
        """
        self.title = "Vacuum MD Simulation"

        self._config_md(integrator, thermostat)

        if self.checkpoint is None:
            self.constraints["continuation"] = "no"
        else:
            self.constraints["continuation"] = "yes"

        self.nb_method["pbc"] = "xyz"
        self.nb_method["ns_type"] = "grid"
        self.nb_method["nstlist"] = 10
        self.nb_method["rlist"] = 333.3
        self.nb_method["coulombtype"] = "Cut-off"
        self.nb_method["rcoulomb"] = 333.3
        self.nb_method["vdwtype"] = "Cut-off"
        self.nb_method["rvdw"] = 333.3
        self.nb_method["DispCorr"] = "no"

    def config_pbc_min(self, optimizer=Optimizer.SteepestDescent):
        """
        Configure a reasonable input setting for an energy minimization run with periodic boundary conditions. `Users
        can override the parameters set by this method.`

        Parameters
        ----------
        optimizer: :class:`GROMACS.Optimizer`, default=Optimizer.SteepestDescent
            Algorithm for energy minimization, keywords in the parenthesis are the options for the input file.
            **(1)** `SteepestDescent` (``steep``), **(2)** `ConjugateGradient` (``cg``), and **(3)** `Broyden`
            (``l-bfgs``).
        """

        self.title = "PBC Minimization"

        self._config_min(optimizer)

        self.nb_method["nstlist"] = 10

    def config_pbc_md(
        self,
        ensemble=Simulation.Ensemble.NPT,
        integrator=Integrator.LeapFrog,
        thermostat=Thermostat.VelocityRescaling,
        barostat=Barostat.Berendsen,
    ):
        """
        Configure a reasonable input setting for a MD run with periodic boundary conditions. `Users can override the
        parameters set by this method.`

        Parameters
        ----------
        ensemble: :class:`Simulation.Ensemble`, default=Ensemble.NPT
            Configure a MD simulation with NVE, NVT or NPT thermodynamic ensemble.
        integrator: :class:`GROMACS.Integrator`, default=Integrator.LeapFrog
            Option to choose the integrator for the MD simulations, keywords in the parenthesis are the options for the
            input file. **(1)** `LeapFrog` (``md``), **(2)** `VelocityVerlet` (``md-vv``),
            **(3)** `VelocityVerletAveK` (``md-vv-avek``), **(4)** `LangevinDynamics` (``sd``), and **(5)**
            `Brownian Dynamics` (``bd``).
        thermostat: :class:`GROMACS.Thermostat`, default=Thermostat.VelocityRescaling
            Option to choose one of five thermostat implemented in GROMACS, keywords in the parenthesis are the options
            for the input file. **(1)** `Off` (``no``), **(2)** `Berendsen` (``berendsen``), **(3)** `NoseHoover`
            (``nose-hoover``), **(4)** `Andersen1` (``andersen``), **(5)** `Andersen2` (``andersen-massive``),
            and **(6)** `VelocityRescaling` (``v-rescale``).
        barostat: :class:`GROMACS.Barostat`, default=Barostat.Berendsen
            Option to choose one of three barostat implemented in GROMACS, keywords in the parenthesis are the options
            for the input file. **(1)** `Off` (``no``), **(2)** `Berendsen` (``berendsen``), **(3)** `ParrinelloRahman`
            (``Parrinello-Rahman``), and **(4)** `MMTK` (``MTTK``).
        """
        self.title = f"{ensemble.value} MD Simulation"

        self._config_md(integrator, thermostat)

        if self.checkpoint is None:
            self.constraints["continuation"] = "no"
        else:
            self.constraints["continuation"] = "yes"

        if ensemble == self.Ensemble.NVE:
            self.thermostat["tcoupl"] = self.Thermostat.Off.value
            self.barostat["pcoupl"] = self.Barostat.Off.value
            del self.thermostat["tc-grps"]
            del self.thermostat["ref_t"]
            del self.thermostat["tau_t"]

        elif ensemble == self.Ensemble.NVT:
            self.thermostat["gen_vel"] = "yes"
            self.thermostat["gen_temp"] = self.temperature
            self.thermostat["gen_seed"] = -1
            self.barostat["pcoupl"] = self.Barostat.Off.value

        elif ensemble == self.Ensemble.NPT:
            self.thermostat["gen_vel"] = "no"
            self.barostat["pcoupl"] = barostat.value
            if barostat.value != self.Barostat.Off:
                self.barostat["pcoupltype"] = self.BoxScaling.Isotropic.value
                self.barostat["tau_p"] = 2.0
                self.barostat["ref_p"] = self.pressure
                self.barostat["compressibility"] = 4.5e-5

    @staticmethod
    def _write_dict_to_mdp(f, dictionary):
        """
        Write dictionary to file, following GROMACS format.

        Parameters
        ----------
        f : TextIO
            File where the dictionary should be written.
        dictionary : dict
            Dictionary of values.
        """
        for key, val in dictionary.items():
            if val is not None and not isinstance(val, list):
                f.write("{:25s} {:s}\n".format(key, "= " + str(val)))
            elif isinstance(val, list):
                f.write("{:25s} {:s}".format(key, "= "))
                for i in val:
                    f.write("{:s} ".format(str(i)))
                f.write("\n")

    def _write_input_file(self):
        """
        Write the input file specification to file.
        """
        logger.debug("Writing {}".format(self.input))
        with open(os.path.join(self.path, self.input), "w") as mdp:
            mdp.write("{:25s} {:s}\n".format("title", "= " + self.title))

            mdp.write("; Run control\n")
            self._write_dict_to_mdp(mdp, self.control)

            mdp.write("; Nonbonded options\n")
            self._write_dict_to_mdp(mdp, self.nb_method)

            mdp.write("; Bond constraints\n")
            if self.constraints["constraint-algorithm"].lower() == "shake":
                self._write_dict_to_mdp(
                    mdp,
                    get_dict_without_keys(
                        self.constraints, "lincs_iter", "lincs_order"
                    ),
                )
            else:
                self._write_dict_to_mdp(mdp, self.constraints)

            if self.thermostat:
                mdp.write("; Temperature coupling\n")

                # Check if users specify different temperature groups
                if self.tc_groups:
                    tau_t = self.thermostat["tau_t"]
                    self.thermostat["tc-grps"] = self.tc_groups
                    self.thermostat["tau_t"] = [tau_t] * len(self.tc_groups)
                    self.thermostat["ref_t"] = [self.temperature] * len(self.tc_groups)

                self._write_dict_to_mdp(mdp, self.thermostat)

            if self.barostat:
                mdp.write("; Pressure coupling\n")
                self._write_dict_to_mdp(mdp, self.barostat)

    def run(self, run_grompp=True, overwrite=False, fail_ok=False):
        """
        Method to run Molecular Dynamics simulation with GROMACS.

        Parameters
        ----------
        run_grompp: bool, optional, default=True
            Run GROMPP to generate ``.tpr`` file before running MDRUN
        overwrite: bool, optional, default=False
            Whether to overwrite simulation files.
        fail_ok: bool, optional, default=False
            Whether a failing simulation should stop execution of ``pAPRika``.
        """

        if overwrite or not self.check_complete():
            # Check the type of simulation: Minimization, NVT or NPT
            if self.control["integrator"] in [
                self.Optimizer.SteepestDescent.value,
                self.Optimizer.ConjugateGradient.value,
                self.Optimizer.Broyden.value,
            ]:
                logger.info("Running Minimization at {}".format(self.path))
            elif self.control["integrator"] in [
                self.Integrator.LeapFrog.value,
                self.Integrator.VelocityVerlet.value,
                self.Integrator.VelocityVerletAveK.value,
                self.Integrator.LangevinDynamics.value,
                self.Integrator.BrownianDynamics.value,
            ]:
                if self.thermostat and self.barostat:
                    logger.info("Running NPT MD at {}".format(self.path))
                elif not self.barostat:
                    logger.info("Running NVT MD at {}".format(self.path))
                else:
                    logger.info("Running NVE MD at {}".format(self.path))

            # Set Plumed kernel library to path
            self._set_plumed_kernel()

            # create executable list for GROMPP
            # gmx grompp -f npt.mdp -c coordinates.gro -p topology.top -t checkpoint.cpt -o npt.tpr -n index.ndx
            if run_grompp:
                # Clean previously generated files
                for file in glob.glob(os.path.join(self.path, f"{self.prefix}*")):
                    os.remove(file)

                # Write MDF input file
                self._write_input_file()

                # GROMPP list
                grompp_list = [self.executable, "grompp"]

                grompp_list += [
                    "-f",
                    self.input,
                    "-p",
                    self.topology,
                    "-c",
                    self.coordinates,
                    "-o",
                    self.tpr,
                    "-po",
                    self.output,
                    "-maxwarn",
                    str(self.grompp_maxwarn),
                ]
                if self.checkpoint:
                    grompp_list += ["-t", self.checkpoint]

                if self.index_file:
                    grompp_list += ["-n", self.index_file]

                # Run GROMPP
                grompp_output = subprocess.Popen(
                    grompp_list,
                    cwd=self.path,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    env=os.environ,
                )
                grompp_stdout = grompp_output.stdout.read().splitlines()
                grompp_stderr = grompp_output.stderr.read().splitlines()

                # Report any stdout/stderr which are output from execution
                if grompp_stdout:
                    logger.info("STDOUT received from GROMACS execution")
                    for line in grompp_stdout:
                        logger.info(line)

                # Not sure how to do this more efficiently/elegantly, "subprocess" seems to treat everything
                # Gromacs spits out from "grompp" as an error.
                if grompp_stderr and any(
                    ["Error" in line.decode("utf-8").strip() for line in grompp_stderr]
                ):
                    logger.info("STDERR received from GROMACS execution")
                    for line in grompp_stderr:
                        logger.error(line)

            # create executable list for MDRUN
            # gmx_mpi mdrun -v -deffnm npt -nt 6 -gpu_id 0 -plumed plumed.dat
            mdrun_list = []

            # Add any user specified command
            if self.custom_mdrun_command is not None:
                if self.executable not in self.custom_mdrun_command:
                    mdrun_list += [self.executable]

                if "mdrun" not in self.custom_mdrun_command:
                    mdrun_list += ["mdrun"]

                mdrun_list += self.custom_mdrun_command.split()

                # Output prefix
                if "-deffnm" not in self.custom_mdrun_command:
                    mdrun_list += ["-deffnm", self.prefix]

                # Add number of threads if not already specified in custom
                if not any(
                    [
                        cpu in self.custom_mdrun_command
                        for cpu in ["-nt", "-ntomp", "-ntmpi", "-ntomp_pme"]
                    ]
                ):
                    mdrun_list += [
                        "-ntomp" if "mpi" in self.executable else "-nt",
                        str(self.n_threads),
                    ]

                # Add gpu id if not already specified in custom
                if (
                    self.gpu_devices is not None
                    and "-gpu_id" not in self.custom_mdrun_command
                ):
                    mdrun_list += ["-gpu_id", str(self.gpu_devices)]

                # Add plumed file if not already specified in custom
                if self.plumed_file and "-plumed" not in self.custom_mdrun_command:
                    mdrun_list += ["-plumed", self.plumed_file]

            else:
                mdrun_list += [self.executable, "mdrun", "-deffnm", self.prefix]

                # Add number of threads
                mdrun_list += [
                    "-ntomp" if "mpi" in self.executable else "-nt",
                    str(self.n_threads),
                ]

                # Add gpu id
                if self.gpu_devices is not None:
                    mdrun_list += ["-gpu_id", str(self.gpu_devices)]

                # Add plumed file
                if self.plumed_file is not None:
                    mdrun_list += ["-plumed", self.plumed_file]

            # Run MDRUN
            mdrun_output = subprocess.Popen(
                mdrun_list,
                cwd=self.path,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=os.environ,
            )
            mdrun_out = mdrun_output.stdout.read().splitlines()
            mdrun_err = mdrun_output.stderr.read().splitlines()

            # Report any stdout/stderr which are output from execution
            if mdrun_out:
                logger.info("STDOUT received from MDRUN execution")
                for line in mdrun_out:
                    logger.info(line)

            # Same reasoning as before for "grompp".
            if mdrun_err and any(
                ["Error" in line.decode("utf-8").strip() for line in mdrun_err]
            ):
                logger.info("STDERR received from MDRUN execution")
                for line in mdrun_err:
                    logger.error(line)

            # Check completion status
            if (
                self.control["integrator"]
                in [
                    self.Optimizer.SteepestDescent.value,
                    self.Optimizer.ConjugateGradient.value,
                    self.Optimizer.Broyden.value,
                ]
                and self.check_complete()
            ):
                logger.info("Minimization completed...")
            elif self.check_complete():
                logger.info("Simulation completed...")
            else:
                logger.info(
                    "Simulation did not complete when executing the following ...."
                )
                logger.info(" ".join(mdrun_list))
                if not fail_ok:
                    raise Exception(
                        "Exiting due to failed simulation! Check logging info."
                    )

        else:
            logger.info(
                "Completed output detected ... Skipping. Use: run(overwrite=True) to overwrite"
            )

    def check_complete(self, alternate_file=None):
        """
        Check for the string "step N" in ``self.output`` file. If "step N" is found, then
        the simulation completed.

        Parameters
        ----------
        alternate_file : os.PathLike, optional, default=None
            If present, check for "step N" in this file rather than ``self.output``.
            Default: None

        Returns
        -------
        complete : bool
            True if "step N" is found in file. False, otherwise.
        """
        # Assume not completed
        complete = False

        if alternate_file:
            output_file = alternate_file
        else:
            output_file = os.path.join(self.path, self.logfile)

        if os.path.isfile(output_file):
            with open(output_file, "r") as f:
                strings = f.read()
                if (
                    f" step {self.control['nsteps']} " in strings
                    or "Finished mdrun" in strings
                ):
                    complete = True

        if complete:
            logger.debug("{} has TIMINGS".format(output_file))
        else:
            logger.debug("{} does not have TIMINGS".format(output_file))

        return complete
